<html>
  <head>
      <title>Is it Wednesday my dudes?</title>

      <style>
          body
          {
              margin: 0;
          }

          canvas
          {
              width: 100%;
              height: 100%;
          }
      </style>
  </head>

  <body>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/STLLoader.js"></script>

    <script src="js/postprocessing/OutlinePass.js"></script>
    <script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>

    <script src="js/shaders/CopyShader.js"></script>

    <script>
      var camera, scene, renderer, controls;

      var raycaster = new THREE.Raycaster();

      var mouse = new THREE.Vector2();
			var selectedObjects = [];

      var composer, OutlinePass;

      var obj3d = new THREE.Object3D();

      var params = {
				edgeStrength: 3.0,
				edgeGlow: 0.0,
				edgeThickness: 1.0,
				pulsePeriod: 0,
				rotate: false,
				usePatternTexture: false
			};

      init();
			animate();

			function init() {
        var width = window.innerWidth;
				var height = window.innerHeight;
				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				// todo - support pixelRatio in this demo
				renderer.setSize( width, height );
				document.body.appendChild( renderer.domElement );
				scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
				camera.position.set( 0, 0, 8 );
        controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.minDistance = 5;
				controls.maxDistance = 20;
				controls.enablePan = false;
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;

        outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );

        var shadowqual = 4096;

        var spotLight = new THREE.SpotLight(0xffffff, 1.5);
        spotLight.position.set(4, 3, 6);
        spotLight.castShadow = true;
        spotLight.shadow.bias = -.002;
        spotLight.shadow.mapSize.width = shadowqual;
        spotLight.shadow.mapSize.height = shadowqual;
        scene.add(spotLight);

        var loader = new THREE.STLLoader();
      loader.load
      (
        'models/droid.stl', //
        function(object)
        {
          object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							child.geometry.center();
							child.geometry.computeBoundingSphere();
							scale = 0.2 * child.geometry.boundingSphere.radius;
							var phongMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shininess: 5 } );
							child.material = phongMaterial;
							child.receiveShadow = true;
							child.castShadow = true;
						}
					} );
					object.position.y = 1;
					object.scale.divideScalar( scale );
					obj3d.add( object );
        }
      );

      scene.add(obj3d);

      var floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );
				var floorGeometry = new THREE.PlaneBufferGeometry( 12, 12 );
				var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
				floorMesh.rotation.x -= Math.PI * 0.5;
				floorMesh.position.y -= 1.5;
				scene.add( floorMesh );
				floorMesh.receiveShadow = true;



        composer = new THREE.EffectComposer( renderer );
				var renderPass = new THREE.RenderPass( scene, camera );
				composer.addPass( renderPass );

				composer.addPass( outlinePass );
				var onLoad = function ( texture ) {
					outlinePass.patternTexture = texture;
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;
				};

        window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'mousemove', onTouchMove );
				window.addEventListener( 'touchmove', onTouchMove );
				function onTouchMove( event ) {
					var x, y;
					if ( event.changedTouches ) {
						x = event.changedTouches[ 0 ].pageX;
						y = event.changedTouches[ 0 ].pageY;
					} else {
						x = event.clientX;
						y = event.clientY;
					}
					mouse.x = ( x / window.innerWidth ) * 2 - 1;
					mouse.y = - ( y / window.innerHeight ) * 2 + 1;
					checkIntersection();
				}
				function addSelectedObject( object ) {
					selectedObjects = [];
					selectedObjects.push( object );
				}
				function checkIntersection() {
					raycaster.setFromCamera( mouse, camera );
					var intersects = raycaster.intersectObjects( [ scene ], true );
					if ( intersects.length > 0 ) {
						var selectedObject = intersects[ 0 ].object;
						addSelectedObject( selectedObject );
						outlinePass.selectedObjects = selectedObjects;
					} else {
						// outlinePass.selectedObjects = [];
					}
				}
      }

      function onWindowResize() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );
				composer.setSize( width, height );
				// effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				// stats.begin();
				var timer = performance.now();
				controls.update();
				composer.render();
				// stats.end();
			}
    </script>
  </body>
</html>
